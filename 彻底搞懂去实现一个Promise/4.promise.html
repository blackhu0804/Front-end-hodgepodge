<script type="text/javascript">
	/*
		支持链式操作
		我们平时写promise一般都是对应的一组流程化的操作，如这样：
		promise.then(f1).then(f2).then(f3)
	*/
	const PENDING = 'pending';
	const FULFILLED = 'fulfilled';
	const REJECTED = 'rejected';

	function myPromise(fn) {
        let self = this
        self.value = null // 成功时的值
        self.error = null // 失败的原因
        self.status = PENDING // 定义初始状态为pending
        self.onFulfilledCallbacks = [] // 成功的回调
        self.onRejectedCallbacks  = [] // 失败的回调

        function resolve(value) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为fulfilled并执行成功逻辑
        		setTimeout( () => {
        			self.status = FULFILLED;
	            	self.value = value
	            	self.onFulfilledCallbacks.forEach( callback => callback(self.value) )
	            })	
        	}
        }

        function reject(error) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为rejected并执行失败逻辑
        		setTimeout( () => {
        			self.status = REJECTED;
	        		self.error = error
	        		self.onRejectedCallbacks.forEach( callback => callback(self.error) )
	        	})
        	}    
        }

        fn(resolve, reject)
    }

    myPromise.prototype.then = function(onFulfilled, onRejected) {
        if(this.status === PENDING) {
        	this.onFulfilledCallbacks.push(onFulfilled)
        	this.onRejectedCallbacks.push(onRejected)
        } else if (this.status === FULFILLED) {
        	onFulfilled(this.value)
        } else {
        	onRejected(this.error)
        }
        return this
    };

    var p = new myPromise( (resolve, reject) => {
        setTimeout( () => {
        	if(Math.random() > 0.5) {
        		resolve('resolve')
        	} else {
        		reject('error')
        	}
        })
    })

    function f1(value) {
        console.log("f1:" + value)
    }

	function f2(value) {
        console.log("f2:" + value)
    }

    function reject(error) {
        console.log(error)
    }

    p.then(f1, reject).then(f2, reject)
</script>