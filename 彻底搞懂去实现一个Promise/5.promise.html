<script type="text/javascript">
	/*
		支持串行异步任务 
		实现了链式调用，但是目前then方法里只能传入同步任务，但是我们平常用promise，then方法里一般是异步任务，因为我们用promise主要用来解决一组流程化的异步操作

		要想实现异步操作串行，我们不能将回调函数都注册在初始promise的onFulfilledCallbacks里面，而要将每个回调函数注册在对应的异步操作promise的onFulfilledCallbacks里面

		我们其实让then方法最后不再返回自身实例，而是返回一个新的promise即可，我们可以叫它bridgePromise，它最大的作用就是衔接后续操作，我们看下具体实现代码：
	*/
	const PENDING = 'pending';
	const FULFILLED = 'fulfilled';
	const REJECTED = 'rejected';

	function myPromise(fn) {
        let self = this
        self.value = null // 成功时的值
        self.error = null // 失败的原因
        self.status = PENDING // 定义初始状态为pending
        self.onFulfilledCallbacks = [] // 成功的回调
        self.onRejectedCallbacks  = [] // 失败的回调

        function resolve(value) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为fulfilled并执行成功逻辑
        		setTimeout( () => {
        			self.status = FULFILLED;
	            	self.value = value
	            	self.onFulfilledCallbacks.forEach( callback => callback(self.value) )
	            })	
        	}
        }

        function reject(error) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为rejected并执行失败逻辑
        		setTimeout( () => {
        			self.status = REJECTED;
	        		self.error = error
	        		self.onRejectedCallbacks.forEach( callback => callback(self.error) )
	        	})
        	}    
        }

        fn(resolve, reject)
    }

    myPromise.prototype.then = function(onFulfilled, onRejected) {
        let self = this
        let bridgePromise;
        // 防止使用者不传成功或失败回调函数，所以成功失败回调都给了默认回调函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        onRejected = typeof onRejected === 'function' ? onRejected : error => error

    	if (self.status === FULFILLED) {
    		return bridgePromise = new myPromise( (resolve, reject) => {
    			setTimeout( () => {
    				try {
	    				let x = onFulfilled(self.value)
	    				resolvePromise(bridgePromise, x, resolve, reject)
	    			} catch (e) {
	    				reject(e)
	    			}
    			})
    		})
    	}

    	if (self.status === REJECTED) {
    		return bridgePromise = new myPromise( (resolve, reject) => {
    			setTimeout( () => {
    				try {
	    				let x = onRejected(self.error)
	    				resolvePromise(bridgePromise, x, resolve, reject)
	    			} catch (e) {
	    				reject(e)
	    			}
    			})
    		})
    	}

    	if (self.status === PENDING) {
    		return bridgePromise = new myPromise( (resolve, reject) => {
    			self.onFulfilledCallbacks.push( (value) => {
	    			try {
	    				let x = onFulfilled(value)
	    				resolvePromise(bridgePromise, x, resolve, reject)
	    			} catch(e) {
	    				reject(e)
	    			}
	    		})

	    		self.onRejectedCallbacks.push( (error) => {
	    			try {
	    				let x = onRejected(error)
	    				resolvePromise(bridgePromise, x, resolve, reject)
	    			} catch(e) {
	    				reject(e)
	    			}
	    		})
    		})
    	}
    };

    //catch方法其实是个语法糖，就是只传onRejected不传onFulfilled的then方法
    myPromise.prototype.catch = function(onRejected) {
    	return this.then(null, reject)
    }

    //用来解析回调函数的返回值x，x可能是普通值也可能是个promise对象
    function resolvePromise(bridgePromise, x, resolve, reject) {
    	//如果x是一个promise
    	if(x instanceof myPromise) {
    		//如果这个promise是pending状态，就在它的then方法里继续执行resolvePromise解析它的结果，直到返回值不是一个pending状态的promise为止
	        if (x.status === PENDING) {
	        	x.then( y => {
	        		resolvePromise(bridgePromise, y, resolve, reject)
	        	}, error => {
	        		reject(error)
	        	})
	    	} else {
	    		x.then(resolve, reject)
	    	}
    	} else {
    		resolve(x)
    	}
	}

	let p = new myPromise( (resolve, reject) => {
		setTimeout( () => {
			resolve('f1')
		}, 1000)
	})

	function f1(value) {
		console.log("f1: " + value)
		return new myPromise( (resolve, reject) => {
			setTimeout( () => {
				resolve('f2')
			})
		})
	}

	function f2(value) {
		setTimeout( () => {
			console.log("f2: " + value)
		})
	}

	function error(error) {
		consle.log(error)
	}

	p.then(f1, error).then(f2, error)
</script>