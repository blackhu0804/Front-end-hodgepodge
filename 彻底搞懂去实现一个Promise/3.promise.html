首先，我们建立了三种状态"pending","fulfilled","rejected",然后我们在reslove和reject中做判断，只有状态是pending时，才去改变promise的状态，并执行相应操作，另外，我们在then中判断，如果这个promise已经变为"fulfilled"或"rejected"就立刻执行它的回调，并把结果传入。 
<script type="text/javascript">
	/*
		支持三种状态
		1.实现promise的三种状态。
		2.实现promise对象的状态改变，改变只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果
		3.实现一旦promise状态改变，再对promise对象添加回调函数，也会立即得到这个结果。
	*/
	// 定义三种状态
	const PENDING = 'pending';
	const FULFILLED = 'fulfilled';
	const REJECTED = 'rejected';

	function myPromise(fn) {
        let self = this
        self.value = null // 成功时的值
        self.error = null // 失败的原因
        self.status = PENDING // 定义初始状态为pending
        self.onFulfilled = null // 成功的回调
        self.onRejected = null // 失败的回调

        function resolve(value) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为fulfilled并执行成功逻辑
        		setTimeout( () => {
        			self.status = FULFILLED;
	            	self.value = value
	            	self.onFulfilled(self.value)
	            })	
        	}
        }

        function reject(error) {
        	if(self.status === PENDING) {
        		// //如果状态是pending才去修改状态为rejected并执行失败逻辑
        		setTimeout( () => {
        			self.status = REJECTED;
	        		self.error = error
	        	    self.onRejected(self.error)
	        	})
        	}    
        }

        fn(resolve, reject)
    }

    myPromise.prototype.then = function(onFulfilled, onRejected) {
        if(this.status === PENDING) {
        	this.onFulfilled = onFulfilled
        	this.onRejected = onRejected
        } else if (this.status === FULFILLED) {
        	onFulfilled(this.value)
        } else {
        	onRejected(this.error)
        }
        return this
    };

    var p = new myPromise( (resolve, reject) => {
        setTimeout( () => {
        	if(Math.random() > 0.5) {
        		resolve('resolve')
        	} else {
        		reject('error')
        	}
        })
    })

    function resolve(value) {
        console.log(value)
        console.log(this.status)
    }

    function reject(error) {
        console.log(error)
        console.log(this.status)
    }

    p.then(resolve, reject)
</script>